// Version of a cell that only contains the probability data.
// Since this data is constant after sim start it goes under the init category
class InitSimCell {
    constructor(row, col) {
        this.row = row;
        this.col = col;

        // Individual probabilities for each ship type to spawn in the day
        this.probDayCargoSpawn;
        this.probDayPatrolSpawn;
        this.probDayPirateSpawn;

        // Individual probabilities for each ship type to spawn at night, are the same by default
        this.probNightCargoSpawn;
        this.probNightPatrolSpawn;
        this.probNightPirateSpawn;
    }

    // For Debugging
    getIndexAsString() {
        return "Row: " + this.row + ", Col: " + this.col;
    }
}

// This class holds any data that is constant for the duration of the simulation after
// it has been started.
class InitSimData {
    constructor() {
        this.simRunTime = 24 * 60; // Specified in minutes
        this.simTimeStep = 5;      // Specified in minutes
        this.simDimensions = [100, 400]; // 100 rows by 400 columns 
        this.considerDayNight = false; // Specifies if individual day / night settings should be used
        this.cells = [];

        // Initialize the cell array
        for (let i = 0; i < this.simDimensions[0] * this.simDimensions[1]; i++) {
            this.cells.push(new InitSimCell(Math.floor(i / this.simDimensions[1]), i % this.simDimensions[1]));
        }
    }

    getInitCellAtIndex(row, col) {
        return this.cells[(row * this.simDimensions[1]) + (col)];
    }

    toString(indent) {
        let ret = indent + "Sim run time      : " + this.simRunTime + " minutes\n";
        ret += indent + "Sim time step     : " + this.simTimeStep + " minutes\n";
        ret += indent + "Sim dimensions    : [" + this.simDimensions[0] + ", " + this.simDimensions[1] + "]" + "\n";
        ret += indent + "Consider daylight : " + this.considerDayNight + "\n";
        return ret;
    }
}

class Simulation {
    constructor() {
        this.initialConditions = new InitSimData();
        this.currentSimTime = 0;
        this.currentFrameNumber = 0;
        this.frames = []; // Stores all the frames generated by the simulation so far
        this.frames.push(new Frame(this.currentSimTime)); // Create an initial frame at time 0 with no entities
    }

    // Flow of tick() function should be:
    //  (1) Create a new frame from the previous frame (coppy existing entities)
    //  (2) Spawn new entities into the frame (such that after a tick they will "move into the map")
    //  (3) Tick the new frame 
    //  (4) Remove out of bounds entities
    //  (5) Save the ticked frame to the frame list
    tick() {
        this.currentSimTime += this.initialConditions.simTimeStep;
        this.currentFrameNumber += 1;
        // (1)
        let newFrame = new Frame(this.currentSimTime, frames[this.currentFrameNumber - 1]);
        // (2)
        newFrame.addEntity(new CargoShip(0, 50));
        newFrame.addEntity(new PatrolShip(0, 50));
        // (3)
        newFrame.tick();
        // (4)
        //newFrame.pruneEntitiesOutsideRange([0, 400], [0, 100]);
        // (5)
        this.frames.push(newFrame);
    }

    toString() {
        let ret = "=== Sim Data (without initial cond. cells) ===\n";
        ret += "\t" + "Current Sim Time    : " + this.currentSimTime + " minutes \n";
        ret += "\t" + "Current Frame Number: " + this.currentFrameNumber + "\n";
        ret += "\t" + "Initial Conditions  :\n";
        ret += this.initialConditions.toString("\t" + "\t");
        ret += "\t" + "Frames: \n";
        this.frames.forEach(frame => {
            ret += frame.toString("\t" + "\t");
            ret += "\n";
        });
        return ret;
    }
}